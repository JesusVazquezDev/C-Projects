Target3: Susceptible to Integer Overflow

Background:
Since an integer can only store a fixed size of data ( 32 bits), there is a fixed maximum value it can store. 
When a value greater than this maximum value it attempted to be stored, an integer overflow occurs. 
In C, the integer overflow causes undefined behavior — thus it can completely ignore the overflow or abort the program entirely. Most of the time, it is ignored resulting in an unexpected or erroneous result being store. We use this to our advantage. 

Exploit:
By passing in the max integer into our input, count becomes negative due to how overflow is calculated in C. That is:

2^31 % 2^32 = 2,147,483,648 and flips the significant bit , 
making count = -2,147,483,648

This will pass the if statement where count < MAX_WIDGETS. 

Now lets look pass the if condition. 

The memcpy function is structure in the following way:
	Memcpy(void *buffer, void *in, size_t value)

In memcpy, count * sizeof(struct widget_t) calculates a value of size_t. 
Size_t in C is an unsigned integer which can have a max value of 2^32. 
The most important thing is that it must not be negative. 

As we can see: -2^31 (count) * 16 = negative. 

Thus, unsigned int is overflowed and this overflow is handled as follows: 

-2^31	    *     16 % 2^32 , again.
^count		^sizeof(struct widget)

This time however, the result of (-2^31* 16) % 2^32 = 0.
So at this point, memcpy does not copy any bytes into buf. 

This is a problem. We need to change 0 to equal the size of our buffer + 8bytes = 2,648 

Thus, can actually add 2648 on top of our overflowed integer by inputting 2^31 + 166. 
But we were getting a seg fault. 
So we tried 167. No Seg fault
168? SUCCESS! 
168 * 16 = 2,688 bytes so we have 48 bytes we can modify. For simplicity, we’ll just write until 2,648 and NOP the rest of the way. 

Thus, we can now successfully overflow our buffer. 

Input:  2^31 + 168 , NOPS + ShellCode + EIP(Return Address to shell) + NOPS.

