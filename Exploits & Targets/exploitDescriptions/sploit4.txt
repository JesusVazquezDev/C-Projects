Use this file to explain how your sploit4 works.

First of all we realized the double free vulnerability at second free(q). Once the second p was allocated, we checked gdb and found the addressed of all 3 of them for reference. So p was 0x08059b48, q was 0x08059a78, and new p was 0x08059478. We then filled the buffer up to 2047 with As to check how everything looks. We used x \200bx (addr) to check how everything was stored and found out a pattern of 80 - 88 - 90 - 98. We then checked the previous 8 byted of each address and found out the left and right pointers of each and kept them for reference. We also know that the last bit is the freebit. 

The new buffer is 2048 bytes long. And after filling with noops, we entered the shellcode at the beginning of the buffer. We then calculated the difference between the new p and q to find out that it was 1536. But this taked us to q when we really want the pointers of q. So we took 8 bytes out of that to reach 1528 (left pointer of q). So buf[1528] is now the address of new p and we changed the right pointer of q (next four bytes) to the location of eip in the function of foo (which was stored in 0xbfff67c) to execute the shellcode. So our new buffer now looks like [shell-nop-new p addr-eip addr-nop].

We then got an error for q and we noticed that it switched the bit of the location of q (in this case 41 for A) to 0 so the new one is 40. It also gives a seg fault and changes the second 4 bytes of the buffer into another address. So to overcome this we changed the location of the shellcode into buf + 8 bytes. The error still occured so we added a jmp ('\xeb''\x06') at the beginning of buf and had that go to the exact location of shellcode which in this case is 0x08059478 + 8. So the new location of shellcode is 0x08059480. Of course it has to end with a null terminator so buf[2047] is \00.
