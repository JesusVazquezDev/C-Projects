Target 5: Exploiting Format Strings
Background:
Snprintf is used to store a specified string till a specified length in the specified format. 
Purpose of format functions:

• used to convert simple C datatypes to a string representation
• allow to specify the format of the representation
• process the resulting string (output to stderr, stdout, syslog, ...)

How format function works: 
• the format string controls the behaviour of the function
• it specifies the type of parameters that should be printed
• parameters are saved on the stack (pushed)
• saved either directly (by value), or indirectly (by reference)
The Calling function: 
• has to know how many parameters it pushes to the stack, since it has to do the stack correction, when the format function returns

We used the following parameters to exploit the specified string:
%n - number of bytes written so far 
%u - a ‘%u’ sequence is two bytes long and pops four bytes from the stack, which gives a 1:2 byte ratio
%f - a ‘%f’ sequence is two bytes long and pops Eight bytes from the stack, which gives a 1:4 byte ratio


1.Create buffer of equal size to buff

2.  Set the beginning of the input to be our EIP +1 ( 0xbfffffc9c + 1 = 0xbfffffc9d)  (where %n will store the values of bytes written so far)

3. As close to the end as possible, before format string, insert shell code ( this is due to an implication where the last byte of EIP(0xbfffffc9c) cannot be changed(couldn’t find how) so we have to work around the last byte being c1 ( which is why our EIP is 0xbfffffc9d). 

4. Insert malicious format string which modifies our EIP value(Return address to NOPS before shellcode ). 
Malicious string is : ‘%2.0f%12582444u%n’ 
‘%2.0f’  - Pops 8 bytes on the stack. 
‘%12582444u’ – %u standalone nets the addr ( 0x0001dac1) which we can then add 12,582,444 to get 0xbffffac1. 
‘%n’ sets 0xbffffc9d -> 0xbffffac1 

Profit. 
Input: [ EIP Addr ] [ NOPS ] [ SHELLCODE ] [MALICIOUS FORMAT STRING]
